{
  "hash": "85e89efe1046015a6cbee89d42119f7d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nfilters:\n  - pyodide\n---\n\n# Reusability\n\n\n{{< video https://youtu.be/sPpbyXyRlQI >}}\n\n\n\nLet’s look at an example.  Here’s a file I created called Penchord_Wizardry.py.\n\n::: {#d24687d5 .cell execution_count=1}\n``` {.python .cell-code}\nimport random\n\n# Class defining a Penchordian\nclass Penchordian :\n    def __init__(self, name):\n        self.name = name\n        self.is_a_wizard = False\n\n    def write_model(self, type_of_model):\n        print (f\"{self.name} is now writing a {type_of_model} model.\")\n\n    def tell_joke(self, prob_success):\n        if random.uniform(0,1) < prob_success:\n            print (f\"{self.name} attempted a joke.  People loved it!\")\n        else:\n            print (f\"{self.name} attempted a joke.  It fell flat.\")\n\n# Function to turn someone into a wizard\n# Input subject must be an object with a \"name\" string attribute and a\n# \"is_a_wizard\" boolean attribute\ndef turn_into_a_wizard(subject):\n    subject.is_a_wizard = True\n    print (f\"{subject.name} is now a wizard.\")\n```\n:::\n\n\nThen I'm going to create a new file in the **same folder** as `Penchord_Wizardry.py`.\n\n:::{.callout-tip}\nIt is possible to call in functions from a Python file stored in a different folder or subfolder - but it starts getting quite complicated to navigate to them in the code, so we won't cover that today.\n:::\n\nAt the beginning of my new file I'm going to `import Penchord_Wizardry` to get access to the functions from `Penchord_Wizardry.py`.\n\n::: {#c88d13d7 .cell execution_count=2}\n``` {.python .cell-code}\n# import the entire Penchord_Wizardry module (the Penchordian class and the\n# turn_into_a_wizard function)\nimport Penchord_Wizardry\n\nimport random\n\nlist_of_penchordian_names = [\"Dan\", \"Sammi\", \"Kerry\", \"Mike\", \"Anna\", \"Tom\",\n                             \"Amy C\", \"Amy H\", \"Chrissie\"]\n\n# Randomly select three PenCHORDian names\n# random.sample selects three elements from a list without replacement\n# (if you want values to be able to be repicked (replacement), use\n# random.choices)\nchosen_penchordian_names = random.sample(list_of_penchordian_names, 3)\n\nlist_of_penchordians = []\n\n# Create some Penchordian objects using the definition from the imported\n# module\nfor name in chosen_penchordian_names:\n    list_of_penchordians.append(Penchord_Wizardry.Penchordian(name))\n\n# Call a couple of the class methods on the three created Penchordian objects\nfor penchordian in list_of_penchordians:\n    penchordian.write_model(\"Discrete Event Simulation\")\n    penchordian.tell_joke(0.1)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTom is now writing a Discrete Event Simulation model.\nTom attempted a joke.  It fell flat.\nKerry is now writing a Discrete Event Simulation model.\nKerry attempted a joke.  It fell flat.\nChrissie is now writing a Discrete Event Simulation model.\nChrissie attempted a joke.  It fell flat.\n```\n:::\n:::\n\n\nI can also choose just to import the bit(s) of the module I need, rather than the whole thing.\n\nHere we don't import the class `Penchordian`, but we do import the function `turn_into_a_wizard`.\n\n:::{.callout-tip}\nNote that because we've imported the specific function by name, we can just then use `turn_into_a_wizard`.\n:::\n\n::: {#04752f7b .cell execution_count=3}\n``` {.python .cell-code}\n# just import the turn_into_a_wizard function\nfrom Penchord_Wizardry import turn_into_a_wizard\n\n# Define a new class called HSMA, which has two attributes - a name, and an\n# is_a_wizard boolean\nclass HSMA:\n    def __init__(self, name):\n        self.name = name\n        self.is_a_wizard = False\n\n# Create a new HSMA object, whose name is Gandalf\nmy_promising_HSMA = HSMA(\"Gandalf\")\n\n# Turn Gandalf into a wizard using the function we imported from the\n# Penchord_Wizardry module\nturn_into_a_wizard(my_promising_HSMA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGandalf is now a wizard.\n```\n:::\n:::\n\n\nIn comparison, if we imported the whole module instead, our code would look like this:\n\n::: {#b5e3fbd4 .cell execution_count=4}\n``` {.python .cell-code}\n# just import the turn_into_a_wizard function\nimport Penchord_Wizardry\n\n# Define a new class called HSMA, which has two attributes - a name, and an\n# is_a_wizard boolean\nclass HSMA:\n    def __init__(self, name):\n        self.name = name\n        self.is_a_wizard = False\n\n# Create a new HSMA object, whose name is Gandalf\nmy_promising_HSMA = HSMA(\"Gandalf\")\n\n# Turn Gandalf into a wizard using the function we imported from the\n# Penchord_Wizardry module\nPenchord_Wizardry.turn_into_a_wizard(my_promising_HSMA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGandalf is now a wizard.\n```\n:::\n:::\n\n\n",
    "supporting": [
      "reusability_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}