{
  "hash": "739cd58e33d30bd649983f378c04062f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nfilters:\n  - pyodide\n---\n\n# An Introduction to Object Oriented Python\n\n## The structure of a python class\n\n\n{{< video https://youtu.be/iR_825xPblE >}}\n\n\n\nLet’s look at how we write a Class in Python.\n\nWe use the class keyword, followed by whatever we want to call our Class to declare a class.  Note - class names must start with a capital letter.\n\n::: {#d4882871 .cell execution_count=1}\n``` {.python .cell-code}\nclass MyClass:\n\n    def __init__(self, attribute_1, attribute_2):\n        self.attribute_1 = attribute_1\n        self.attribute_2 = attribute_2\n\n    def method_1(self):\n        print (\"This is method 1!\")\n\n    def method_2(self):\n        print (\"This is method 2!\")\n```\n:::\n\n\n### The constructor\n\nThis is the constructor.  It is the method that is automatically called whenever we say we want a new instance of our class (instantiation).  The purpose is to set up the object ready to use.\n\n::: {#a7f16d5d .cell execution_count=2}\n``` {.python .cell-code}\ndef __init__(self, attribute_1, attribute_2):\n    self.attribute_1 = attribute_1\n    self.attribute_2 = attribute_2\n```\n:::\n\n\nHere, the constructor assigns values to a couple of attributes for any newly created instance based on the two values passed in to it (ignore self - I’ll come back to that in a moment).\n\nThe double underscore before and after init indicates this is a dunder method (“dunder”= “double underscore”).  These are also known as “magic methods”.  They’re called automatically when needed.\n\n:::{.callout-tip}\n#### Me, myself, and Self\nself is an important concept in Object Oriented Coding in Python.  Basically, self stores the instance of the class (ie the copy from the blueprint).  It can be a bit weird to get your head around, particularly if you’re new to coding.\n\nWe declare self as the first input to any method definition in the class.  It basically says “Run this class method on this instance” (eg on Dan’s ambulance).  BUT, when we call the method, we don’t include self explicitly (Python does this for us, behind the scenes).\n\nWhenever we need to refer to something belonging to this instance, we say self. to say “Give me the x that belongs to you”.  Eg give me the attribute value that you (Dan’s ambulance) is carrying.  Or run the method that belongs to you.\n\nBasically, by using self we refer to the instance of the class (the individual object) rather than the Class itself (the blueprint).\n\nThis will make more sense as you see examples… Promise… :)\n:::\n\n### Class methods\n\nThese are the methods (functions) that the class has.  Every class needs at least a constructor, but we can add other things too.\n\nThese work exactly the same as any other functions, except we always pass in self as the first input in the method definition (even if there are no other inputs).\n\n::: {#4a162fa6 .cell execution_count=3}\n``` {.python .cell-code}\ndef method_1(self):\n    print (\"This is method 1!\")\n\ndef method_2(self):\n    print (\"This is method 2!\")\n```\n:::\n\n\n## An example python class\n\n\n{{< video https://youtu.be/bhNmDUKY2E8 >}}\n\n\n\nLet’s look at an example to make this a bit more real.\n\nLet’s see how we might translate our ambulance Class into Python.\n\n```{pyodide-python}\n\nclass Ambulance:\n    def __init__(self, name_of_trust, reg_number):\n        self.name_of_trust = name_of_trust\n        self.reg_number = reg_number\n\n        self.patient_on_board = False\n        self.siren_on = False\n\n    def drive(self, speed):\n        print (f\"Now driving at {speed}mph\")\n\n    def park(self, location):\n        print (f\"Now parked at {location}\")\n\n    def load_patient(self, patient_name):\n        self.patient_on_board = True\n        print (f\"{patient_name} now on board\")\n\n    def unload_patient(self, patient_name):\n        self.patient_on_board = False\n        print (f\"{patient_name} unloaded\")\n\n    def turn_on_siren(self):\n        self.siren_on = True\n        print (\"Nee nor nee nor nee nor nee nor nee nor\")\n\n    def turn_off_siren(self):\n        self.siren_on = False\n```\n\n### Instantiating our class (creating an instance of the class)\n\n\n{{< video https://youtu.be/TaMONDMov84 >}}\n\n\n\nWe’ve defined our ambulance class now, but, just as with functions, nothing will happen until we use it.\n\nSo let’s create an instance of the class (instantiation), and play with it a bit.\n\n```{pyodide-python}\ndans_ambulance = Ambulance(\"Chalk NHS Trust\", \"CH41 LKS\")\n```\n\nNote that nothing has been printed out at this point. That's because we've just created the class, so all that's run so far is the code inside the `__init__` method, and there were no statements there that would generate an output.\n\nLet's try using some of the class methods.\n\n```{pyodide-python}\ndans_ambulance.drive(50)\ndans_ambulance.turn_on_siren()\ndans_ambulance.park(\"Cake shop\")\n```\n\nWe can also take a look at the attributes of the class.\n\n```{pyodide-python}\nprint(f\"Name of ambulance: {dans_ambulance.name_of_trust}\")\n\nprint(f\"Registration number: {dans_ambulance.reg_number}\")\n\nprint(f\"Is there a patient on board?: {dans_ambulance.patient_on_board}\")\n\nprint(f\"Is the siren on?: {dans_ambulance.siren_on}\")\n```\n\n### Multiple instances of the same class\n\nA key advantage of OOP is that we only need to define a class once, and then can have multiple instances of it doing different things.\n\nWhilst Dan’s taken his ambulance off (siren blaring) to the cake shop, maybe Sammi’s actually attending the scene of an incident…\n\n```{pyodide-python}\nsammis_ambulance = Ambulance(\"Rosser Healthcare\", \"HS44 MAS\")\n\nsammis_ambulance.drive(70)\nsammis_ambulance.turn_on_siren()\nsammis_ambulance.park(\"M23 Junction 42\")\nsammis_ambulance.load_patient(\"Jack Shepherd\")\nsammis_ambulance.drive(70)\nsammis_ambulance.park(\"Dharma Hospital\")\nsammis_ambulance.turn_off_siren()\nsammis_ambulance.unload_patient(\"Jack Shepherd\")\n\n```\n\nWe can see how certain attributes change over time as well.\n\nAt the moment, we have no patient in our ambulance.\n\nLet's check the `patient_on_board` attribute.\n\n```{pyodide-python}\nprint(f\"Is there a patient on board?: {sammis_ambulance.patient_on_board}\")\n```\n\nNow let's load another patient. To recap, this is what the `load_patient` method will do...\n\n::: {#8588f848 .cell execution_count=4}\n``` {.python .cell-code}\ndef load_patient(self, patient_name):\n    self.patient_on_board = True\n    print (f\"{patient_name} now on board\")\n```\n:::\n\n\n```{pyodide-python}\nsammis_ambulance.load_patient(\"Bob Bobson\")\n\nprint(f\"Is there a patient on board?: {sammis_ambulance.patient_on_board}\")\n```\n\nNow, when we unload this patient, the attribute will change again!\n\nTo recap, this is what the `unload_patient` method will do...\n\n::: {#48c1eeaf .cell execution_count=5}\n``` {.python .cell-code}\ndef unload_patient(self, patient_name):\n    self.patient_on_board = False\n    print (f\"{patient_name} unloaded\")\n```\n:::\n\n\n```{pyodide-python}\nsammis_ambulance.unload_patient(\"Bob Bobson\")\n\nprint(f\"Is there a patient on board?: {sammis_ambulance.patient_on_board}\")\n```\n\n",
    "supporting": [
      "intro_to_oopp_files"
    ],
    "filters": [],
    "includes": {}
  }
}