{
  "hash": "629d995e183ba84ff24103618f6ca75a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nfilters:\n  - pyodide\n---\n\n# Lists\n\n\n{{< video https://youtu.be/8DlOv18BoqM >}}\n\n\n\nLists are extremely useful in Python, allowing us to store multiple items of ordered data to which we can refer later.\n\nWe can create an empty list if we want - to do this we just use two square brackets with nothing in between.\n\n```{pyodide-python}\n# Define a new empty list\n\nmy_empty_list = []\n```\n\nHowever, you'll often want to create a list with some elements already in it.\n\n```{pyodide-python}\n# Define a new list with some starting elements\n\nmy_list = [3, 4, 7, \"hello\"]\n\nprint(my_list)\n```\n\nWe can also add an extra item to a list.\n\n```{pyodide-python}\n\n# Define a new list with some starting elements\n\nmy_list = [3, 4, 7, \"hello\"]\n\nprint(f\"Here is our original list: {my_list}\")\n\nmy_list.append(2)\n\nprint(f\"Here is our updated list: {my_list}\")\n\n```\n\nNote that we didn't **assign** the new list back to the variable `my_list`.\n\ni.e. we didn't write\n\n```\nmy_list = my_list.append(2)\n```\n\nThis is because append updates the object without needing to be assigned!\n\n:::{.callout-info}\nWhy is append written after my_list instead of before?\n\nThis is because it's a *method* of the list *class*.\nThe dot here is known as dot notation.  We’ll cover this more in Object Oriented Programming, but basically a dot is a way of getting to the methods (functions) and attributes (variables) stored in an object (a list object here).\n\nSo this line says “Use the append **method** of a **list object**”\n:::\n\n## Indices\n\n\n{{< video https://youtu.be/8JlVrOqvm4M >}}\n\n\n\nLists are ordered, which means that we can refer to elements in a list by their location - their index.\n\nTo refer to an element in a list by its index, we use the following notation :\n\n::: {#e503061f .cell execution_count=1}\n``` {.python .cell-code}\nmy_list[x]\n```\n:::\n\n\nwhere x is the index number of the element we want to reference.\n\nHOWEVER, Python (like many languages) starts counting from 0.  Which means the first element of a list has an index of 0, the second an index of 1 etc.  This will catch you out if you’re new to coding, especially as a few constructs in Python start counting from 1…\n\nSo, to reference the fourth element in a list my_list, we would use :\n\n::: {#bf5af250 .cell execution_count=2}\n``` {.python .cell-code}\nmy_list[3]\n```\n:::\n\n\nLet's run this below!\nTry changing the index (the '3') in the line `print(my_list[3])`\n\n```{pyodide-python}\n\n# Define a new list with some starting elements\n\nmy_list = [3, 4, 7, \"hello\"]\n\nprint(my_list[3])\n```\n\n## Negative Indexing and Slicing\n\n\n{{< video https://youtu.be/Snzu2JeHioo >}}\n\n\n\nWe can also use negative indexing to refer to an item based on its position from the end of the list.  Here, -1 would refer to the last element, -2 to the penultimate element etc.\n\n```{pyodide-python}\n\n# Define a new list with some starting elements\n\nmy_list = [3, 4, 7, \"hello\"]\n\nprint(my_list[-2])\n```\n\nIf we want to refer to multiple items in a list, we can use a slice.  Here, we use a colon to denote the indices of the start and end elements that we want.\n\n:::{.callout-tip}\nThe start element is included.\n\nThe end element is not included.\n:::\n\n```{pyodide-python}\n\n# Define a new list with some starting elements\n\nmy_list = [3, 4, 7, \"hello\"]\n\nprint(my_list[1:3])\n\nprint(my_list[:2])\n\nprint(my_list[3:])\n```\n\n## Length and Removal\n\nTo find the length of a list (the number of elements it contains), we simply use the len() function :\n```{pyodide-python}\n\n# Define a new list with some starting elements\n\nmy_list = [3, 4, 7, \"hello\"]\n\nprint(len(my_list))\n```\n\nWe can remove an item from a list by specifying the element we want to remove, and using remove :\n\n```{pyodide-python}\nmy_list = [3, 4, 7, \"hello\"]\n\nprint(f\"Here is our original list: {my_list}\")\n\nmy_list.remove(\"hello\")\n\nprint(f\"Here is our updated list: {my_list}\")\n```\n\nOr by giving the index of the element we want to remove, and using pop:\n\n```{pyodide-python}\nmy_list = [3, 4, 7, \"hello\"]\n\nprint(f\"Here is our original list: {my_list}\")\n\nmy_list.pop(0)\n\nprint(f\"Here is our updated list: {my_list}\")\n```\n\nIf we want to remove the last element from a list, we can just use pop without specifying an index :\n\n\n```{pyodide-python}\nmy_list = [3, 4, 7, \"hello\"]\n\nprint(f\"Here is our original list: {my_list}\")\n\nmy_list.pop()\n\nprint(f\"Here is our updated list: {my_list}\")\n```\n\n## Checking Existence\n\nWe can check whether or not an element exists in a list using conditional logic combined with the in keyword :\n\n```{pyodide-python}\nmy_list = [3, 4, 7, \"hello\"]\n\nif 2 in my_list:\n    print(\"Already there\")\n```\n\nOr whether something is not in a list by additionally using the not keyword :\n\n```{pyodide-python}\nmy_list = [3, 4, 7, \"hello\"]\n\nif 5 not in my_list:\n    print(\"It's not there!\")\n```\n\n\n## Copying lists\n\nIf we want to copy a list, we might be tempted to write this :\n\n::: {#be19ecdf .cell execution_count=3}\n``` {.python .cell-code}\nmy_list = [3, 4, 7, \"hello\", 2]\ncopy_of_my_list = my_list\n```\n:::\n\n\nThe previous example will create a second reference to the same list.  In other words, there is still one list, just two different names for it.\n\nTo create a copy, we need to use the copy() function of a list object :\n\n::: {#3bfa7d34 .cell execution_count=4}\n``` {.python .cell-code}\nmy_list = [3, 4, 7, \"hello\", 2]\ncopy_of_my_list = my_list.copy()\n```\n:::\n\n\nNow we have two lists, and can work with them independently (ie changes made to one will not affect the other).\n\n",
    "supporting": [
      "lists_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}